#!/usr/bin/env python
#
# License: BSD
#   https://raw.github.com/yujinrobot/gopher_crazy_hospital/license/LICENSE
#
##############################################################################
# Documentation
##############################################################################
"""
Simple test program for py trees
"""
##############################################################################
# Imports
##############################################################################

import rospy
#import py_trees.coroutines as pi_trees
import py_trees

##############################################################################
# Behaviours
##############################################################################


class Count(py_trees.Behaviour):
    def __init__(self, name="Count", fail_until=3, running_until=5, success_until=6, *args, **kwargs):
        super(Count, self).__init__(name, *args, **kwargs)
        self.count = 0
        self.fail_until = fail_until
        self.running_until = running_until
        self.success_until = success_until

    def terminate(self, new_status):
        print("  %s [Count::terminate()]" % self.name)
        # reset only if udpate got us into an invalid state
        if new_status == py_trees.Status.INVALID:
            self.count = 0

    def update(self):
        self.count += 1
        if self.count <= self.fail_until:
            print("  %s [Count::update()][%s -> FAILURE]" % (self.name, self.count))
            return py_trees.Status.FAILURE
        elif self.count <= self.running_until:
            print("  %s [Count::update()][%s -> RUNNING]" % (self.name, self.count))
            return py_trees.Status.RUNNING
        elif self.count <= self.success_until:
            print("  %s [Count::update()][%s -> SUCCESS]" % (self.name, self.count))
            return py_trees.Status.SUCCESS
        else:
            print("  %s [Count::update()][%s -> FAILURE]" % (self.name, self.count))
            return py_trees.Status.FAILURE


##############################################################################
# Visitors
##############################################################################

class Visitor:
    def __init__(self):
        pass

    def run(self, behaviour):
        print("  %s [visited][%s]" % (behaviour.name, behaviour.status))


##############################################################################
# Parameters
##############################################################################

class Parameters:
    test_sequences = False
    test_selectors = False
    test_combined = True

##############################################################################
# Main
##############################################################################

if __name__ == '__main__':
    # rospy.init_node('test_pi_trees')

    visitor = Visitor()

    if Parameters.test_sequences:
        sequence_tree = py_trees.Sequence()
        sequence_tree.add_child(Count(name="SequenceCounter1", fail_until=0, running_until=3, success_until=5))
        sequence_tree.add_child(Count(name="SequenceCounter2", fail_until=0, running_until=3, success_until=5))
        sequence_tree.add_child(Count(name="SequenceCounter3", fail_until=0, running_until=3, success_until=5))

        for i in range(0, 5):
            print("Run [%s]" % i)
            for node in sequence_tree.tick():
                print("  %s [visited][%s]" % (node.name, node.status))

    if Parameters.test_selectors:
        selector_tree = py_trees.Selector()
        selector_tree.add_child(Count(name="A"))
        selector_tree.add_child(Count(name="B"))
        selector_tree.add_child(Count(name="C", fail_until=0, running_until=3, success_until=15))
        for i in range(0, 10):
            print("Run [%s]" % i)
            for node in selector_tree.tick():
                print("  %s [visited][%s]" % (node.name, node.status))

    if Parameters.test_combined:
        tree = py_trees.Selector()
        tree.add_child(Count(name="Front", fail_until=3, running_until=5, success_until=7))
        sequence = py_trees.Sequence()
        sequence.add_child(Count(name="SequenceCounter1", fail_until=0, running_until=3, success_until=5))
        sequence.add_child(Count(name="SequenceCounter2", fail_until=0, running_until=3, success_until=5))
        tree.add_child(sequence)
        tree.add_child(Count(name="Back", fail_until=0, running_until=3, success_until=15))
        for i in range(0, 5):
            print("Run [%s]" % i)
            for node in tree.tick():
                node.visit(visitor)

    # one step style, call the generator
    #for i in range(1, 10):
    #    status = next(tree.iterator)
    #    print("Iterate %s" % status)
    # for status in tree.iterator:
    #    print("Iterate %s" % status)
    #print("Tick: %s" % tree.tick())
    #print("Tick: %s" % tree.tick())

    #py_trees.display.print_ascii_tree(tree)
    #py_trees.display.print_dot_tree(tree)
