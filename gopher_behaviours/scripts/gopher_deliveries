#!/usr/bin/env python
#
# License: BSD
#   https://raw.github.com/yujinrobot/gopher_crazy_hospital/license/LICENSE
#
##############################################################################
# Documentation
##############################################################################
"""
Simple demo program for py trees
"""
##############################################################################
# Imports
##############################################################################

import gopher_behaviours
from gopher_behaviours.planner import Planner
import gopher_std_msgs.msg as gopher_std_msgs
import gopher_std_msgs.srv as gopher_std_srvs
import std_msgs.msg as std_msgs
import py_trees
from py_trees.common import Status
import rospy

##############################################################################
# Support Classes
##############################################################################


def show_usage(root):
    print("")
    print("************************************************************************************")
    print("                                 Gopher Compulsion")
    print("************************************************************************************")
    print("")
    print("Warm, fuzzy, furry, behavioural experiments")
    print("")
    py_trees.display.print_ascii_tree(root)
    print("")
    print("************************************************************************************")
    print("")

##############################################################################
# Core Controller
##############################################################################


class GopherHiveMind(object):
    def __init__(self):
        self.battery_subtree = gopher_behaviours.battery.create_battery_tree(name="Eating Disorder")
        autoload_test_delivery = rospy.get_param("~autoload_test_delivery", False)
        preloaded_semantic_locations = gopher_behaviours.delivery.desirable_destinations() if autoload_test_delivery else None  # list of gopher_std_msgs.Location objects

        self.planner = Planner(auto_go=rospy.get_param("~dont_wait_for_hoomans", False))
        self.quirky_deliveries = gopher_behaviours.delivery.GopherDeliveries(name="Quirky Deliveries", planner=self.planner, semantic_locations=preloaded_semantic_locations)
        self.idle = py_trees.behaviours.Success("Idle")
        self.root = py_trees.Selector(name="HiveMind", children=[self.battery_subtree, self.idle])
        self.tree = py_trees.ROSBehaviourTree(self.root)
        self.logger = py_trees.logging.get_logger("HiveMind")
        self.render = False
        self.success = None  # non goal
        self.cancelled = False

        ##################################
        # Ros Components
        ##################################
        rospy.on_shutdown(self.shutdown)
        self._delivery_goal_service = rospy.Service('delivery/goal', gopher_std_srvs.DeliveryGoal, self._goal_service_callback)
        self._delivery_feedback_publisher = rospy.Publisher('delivery/feedback', gopher_std_msgs.DeliveryFeedback, queue_size=1, latch=True)
        self._delivery_goal_cancel_sub = rospy.Subscriber('delivery/cancel', std_msgs.Empty, self._goal_cancel_callback)
        self._delivery_result_service = rospy.Service('delivery/result', gopher_std_srvs.DeliveryResult, self._result_service_callback)

    ##############################################################################
    # Tick Tock
    ##############################################################################

    def tick_tock(self):
        self.tree.visitors.append(gopher_behaviours.utilities.DebugVisitor())
        self.tree.tick_tock(sleep_ms=500, number_of_iterations=py_trees.CONTINUOUS_TICK_TOCK, pre_tick_handler=self.pre_tick_handler, post_tick_handler=self.post_tick_handler)

    def pre_tick_handler(self, behaviour_tree):
        self.logger.debug("")
        self.logger.debug("{:-^30}".format(" Run %s " % behaviour_tree.count))
        self.logger.debug("")
        self.quirky_deliveries.pre_tick_update()
        if self.quirky_deliveries.has_a_new_goal:
            if self.quirky_deliveries.old_goal_id is not None:
                self.tree.prune_subtree(self.quirky_deliveries.old_goal_id)
            if self.quirky_deliveries.root:
                self.tree.insert_subtree(self.quirky_deliveries.root, self.root.id, 1)
            self.quirky_deliveries.has_a_new_goal = False
            self.cancelled = False # reset cancelled flag upon receiving a new goal
            print("")
            print("************************************************************************************")
            print("                   Gopher Compelled (Behaviour Tree Update)")
            print("************************************************************************************")
            py_trees.display.print_ascii_tree(self.tree.root)
            print("************************************************************************************")
            print("")

    def post_tick_handler(self, behaviour_tree):
        """
        Post results on the delivery feedback/results publishers.

        Could/should possibly move this into the delivery class itself.
        """
        if self.render:
            py_trees.display.render_dot_tree(self.root)
            self.render = False
        self.quirky_deliveries.post_tock_update()
        # make sure to publish one last message to the feedback publisher once the task has succeded
        if self.quirky_deliveries.is_executing() or (self.quirky_deliveries.succeeded_on_last_tick() and not self.success):
            msg = gopher_std_msgs.DeliveryFeedback()
            msg.header.stamp = rospy.Time.now()
            msg.state = self.quirky_deliveries.state
            msg.traversed_locations = self.quirky_deliveries.blackboard.traversed_locations
            msg.remaining_locations = self.quirky_deliveries.blackboard.remaining_locations
            msg.status_message = self.quirky_deliveries.feedback_message
            self._delivery_feedback_publisher.publish(msg)
        if self.quirky_deliveries.succeeded_on_last_tick():
            self.success = True

    ##############################################################################
    # Ros Methods
    ##############################################################################

    def _goal_service_callback(self, request):
        '''
        Accept (or not) a delivery goal. Right now we refuse any goals assigned to us after the first.

        :param gopher_std_msgs.srv.DeliveryGoalRequest request: goal information

        .. todo::

           * check goal semantic locations are registered ones
           * check for homebase at front or back before pre-post fixing
           * check there is at least one location
           * check battery level via rocon_python_comms.ServiceProxy for a latched publisher
           * switch battery charging upon acceptance of a goal
           * check the first preempted goal location isn't the same as the current location and handle it
        '''
        rospy.loginfo("Delivery : received a goal request: {0}".format(request))
        # first, check if we're already doing something in the battery monitor
        # part of the tree. If we are, we do not accept any new goals.
        if self.battery_subtree.status != Status.FAILURE:
            result = gopher_std_msgs.DeliveryErrorCodes.NOT_ENOUGH_JUICE
            message = "refused goal request : [Not enough battery power to accept a goal right now.]"
            rospy.logwarn("Delivery : [%s]" % message)
        else:
            (result, message) = self.quirky_deliveries.set_goal(request.semantic_locations)
            if result == gopher_std_msgs.DeliveryErrorCodes.SUCCESS:
                message = "received goal request [%s]" % message
                rospy.loginfo("Delivery : [%s]" % message)
                self.success = False
            else:
                message = "refused goal request [%s]" % message
                rospy.logwarn("Delivery : [%s]" % message)
        return gopher_std_srvs.DeliveryGoalResponse(result, message)

    def _goal_cancel_callback(self, cancel):
        # if the delivery root has been initialised
        if self.quirky_deliveries.root:
            # prune the subtree containing the current delivery goal
            self.tree.prune_subtree(self.quirky_deliveries.root.id)
        self.cancelled = True  # set cancelled flag to use in result service

        print("")
        print("************************************************************************************")
        print("                   Gopher Compelled (Behaviour Tree Update)")
        print("************************************************************************************")
        py_trees.display.print_ascii_tree(self.tree.root)
        print("************************************************************************************")
        print("")

        msg = gopher_std_msgs.DeliveryFeedback()
        msg.header.stamp = rospy.Time.now()
        msg.state = gopher_std_msgs.DeliveryFeedback.CANCELLED
        msg.traversed_locations = self.quirky_deliveries.blackboard.traversed_locations
        msg.remaining_locations = self.quirky_deliveries.blackboard.remaining_locations
        msg.status_message = "Cancellation message was received."
        self._delivery_feedback_publisher.publish(msg)

    def _result_service_callback(self, request):
        '''
        Returns the result if success
        '''

        msg = gopher_std_srvs.DeliveryResultResponse()
        msg.header.stamp = rospy.Time.now()
        msg.traversed_locations = self.quirky_deliveries.blackboard.traversed_locations
        msg.remaining_locations = self.quirky_deliveries.blackboard.remaining_locations

        if self.success:
            msg.result = gopher_std_msgs.DeliveryErrorCodes.SUCCESS
            msg.error_message = "Success !"
        else:
            if self.cancelled:
                msg.result = gopher_std_msgs.DeliveryErrorCodes.CANCELLED
                msg.error_message = "Delivery was cancelled."
            else:
                msg.result = gopher_std_msgs.DeliveryErrorCodes.UNKNOWN
                msg.error_message = "Not finished yet..."

        return msg

    def shutdown(self):
        self.tree.destroy()  # destroy the tree on shutdown to stop the behaviour
        self.tree.interrupt()

##############################################################################
# Main
##############################################################################

if __name__ == '__main__':
    # have to read debug param before initialising node, it's not possible to
    # change the log level after node is initialised.
    debug_mode = rospy.get_param("/gopher_deliveries/debug", False)
    log_lev = rospy.INFO
    if debug_mode:
        py_trees.logging.level = py_trees.logging.Level.DEBUG
        log_lev = rospy.DEBUG

    rospy.init_node("gopher_compulsion", log_level=log_lev)

    gopher_compulsion = GopherHiveMind()
    gopher_compulsion.tick_tock()
